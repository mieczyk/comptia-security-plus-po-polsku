# 1.4 Explain the importance of using appropriate cryptographic solutions
Wyjaśnij istotę i wagę stosowania odpowiednich rozwiązań kryptograficznych.
# Public key infrastructure (PKI)
Uwaga! Pojęcie infrastruktury klucza publicznego jest ściśle powiązane z certyfikatami cyfrowymi, jednakże w poniższym opracowaniu skupimy się na ogólnym wyjaśnieniu potrzeby istnienia takiej infrastruktury oraz na samych kluczach kryptograficznych. Same certyfikaty zostaną natomiast omówione w jednym z kolejnych opracowań.
## PKI - definicja
**Infrastruktura klucza publicznego** (PKI, *Public Key Infrastructure*) to termin o szerokim znaczeniu, jednak najczęściej stosuje się go w odniesieniu do **kompletnego systemu opartego na kryptografii klucza publicznego, którego celem jest weryfikacja tożsamości oraz wiarygodności użytkowników, systemów lub urządzeń poprzez cyfrowe certyfikaty** (ang. *digital certificates*) wykorzystywane w komunikacji elektronicznej.

Pojęcie _framework_ w tym kontekście obejmuje wszystkie **środki oraz procesy umożliwiające zarządzanie certyfikatami elektronicznymi i komponentami związanymi z szyfrowaniem przy użyciu klucza publicznego** (_public key encryption_). Do wspomnianych **środków** zalicza się takie elementy jak **sprzęt, oprogramowanie oraz sformalizowane polityki (ang. _policies_) i procedury**. Natomiast **zarządzanie certyfikatami** polega na ich **tworzeniu, dystrybucji, przechowywaniu oraz unieważnianiu (ang. _revocation_)**, gdy zachodzi taka potrzeba.

Głównym zadaniem infrastruktury klucza publicznego jest **zapewnienie poufności oraz wiarygodności komunikacji**. W tym celu PKI łączy takie mechanizmy jak kryptografia symetryczna i asymetryczna, [funkcje skrótu (_hashing_)](https://vilya.pl/sy0-701-hashing-pl/) oraz [podpisy cyfrowe](https://vilya.pl/comptia-security-sy0-701-digital-signatures-pl/), a następnie opakowuje je w tzw. **cyfrowe certyfikaty**, o których powiemy sobie więcej w jednym z przyszłych opracowań.
## PKI - poufność
Aby zrozumieć istotę PKI, trzeba najpierw przypomnieć sobie kilka podstawowych pojęć z zakresu kryptografii. Zacznijmy od szyfrowania, które zapewnia poufność komunikacji. Do szyfrowania (oraz odszyfrowywania) wiadomości używa się specjalnych **algorytmów kryptograficznych**, które opierają się na koncepcji **kluczy** (ang. *keys*). **Klucz to pewna wartość, zwykle w postaci ciągu losowych znaków, która służy do _pomieszania_ (szyfrowania) danych w taki sposób, aby nie dało się ich odczytać bez znajomości tego klucza**.

Algorytmy szyfrowania dzielimy głównie na algorytmy **symetryczne** (ang. _symmetric encryption_) oraz **asymetryczne** (ang. _asymmetric encryption_):
- **Kryptografia symetryczna** - ten sam tajny (ang. _secret_) i współdzielony (ang. _shared_) klucz jest wykorzystywany zarówno do zaszyfrowania wiadomości, jak i do jej odszyfrowania. Zaletą tych algorytmów jest duża szybkość działania, a ich główną wadą - trudność bezpiecznego przekazania klucza między uczestnikami komunikacji w taki sposób, aby nie trafił on w niepowołane ręce.
- **Kryptografia asymetryczna** - nazywana również **kryptografią klucza publicznego** (ang. _public key cryptography_) - wykorzystuje parę matematycznie powiązanych kluczy: **publiczny** (ang. *public key*) oraz **prywatny** (ang. *private key*). Jej zasada działania opiera się na tym, że wiadomość zaszyfrowana kluczem publicznym może zostać odszyfrowana wyłącznie przy użyciu powiązanego z nim klucza prywatnego.
	- Odbiorca może więc opublikować swój klucz publiczny (który - jak sama nazwa wskazuje - nie musi być tajny), a dowolny nadawca może go użyć do zaszyfrowania komunikatu. Tylko odbiorca, posiadający odpowiadający mu klucz prywatny (ten już musi pozostać tajny), będzie w stanie odczytać zaszyfrowaną wiadomość.
	- Największą zaletą kryptografii klucza publicznego jest możliwość zapewnienia poufności komunikacji pomiędzy stronami, które wcześniej się nie znały ani nie wymieniały kluczy. Wystarczy, że klucze publiczne są ogólnodostępne. Wadą natomiast jest niższa wydajność w porównaniu do kryptografii symetrycznej.

Biorąc pod uwagę zalety i wady obu podejść, bardzo często stosuje się je łącznie. Podczas nawiązywania połączenia (ustanawiania kanału komunikacji) wykorzystuje się szyfrowanie asymetryczne. Ponieważ działa ono stosunkowo wolno i nie sprawdza się przy przesyłaniu dużych ilości danych, używa się go głównie do _wymiany_ tajnego klucza pomiędzy stronami. Gdy obie strony posiadają już wspólny klucz, dalsza komunikacja odbywa się z wykorzystaniem szyfrowania symetrycznego, które działa znacznie szybciej.

Łącząc się z dowolną stroną internetową przez protokół [HTTPS](https://www.ssl.com/pl/FAQ/co-to-jest-https/), mamy pewność, że przesyłane dane są zaszyfrowane. Nawet jeśli ktoś podsłucha transmisję, bez odpowiedniego klucza prywatnego nie będzie w stanie zrozumieć jej treści. Jest to możliwe dzięki certyfikatom cyfrowym, które zawierają m.in. klucz publiczny właściciela witryny.

W uproszczeniu: przeglądarka, nawiązując połączenie z określoną witryną, pobiera przypisany do niej certyfikat i używa zawartego w nim klucza publicznego do utworzenia poufnego kanału komunikacyjnego. Serwer może odczytać zaszyfrowaną wiadomość, używając swojego klucza prywatnego, powiązanego z kluczem publicznym znajdującym się w certyfikacie.

Aby szyfrowanie asymetryczne działało w obie strony, serwer musiałby używać klucza publicznego klienta. Tu pojawia się jednak pewien problem. Po pierwsze - każdy klient musiałby posiadać własną parę kluczy. Po drugie - algorytmy asymetryczne są mało wydajne. Dlatego, korzystając z utworzonego już bezpiecznego kanału, generowany jest **klucz sesji**. Od tego momentu obie strony komunikują się z wykorzystaniem **szyfrowania symetrycznego przy użyciu współdzielonego klucza sesji**.
## PKI - wiarygodność
Wiemy już, w jaki sposób PKI przyczynia się do zapewnienia dyskretnej komunikacji za pośrednictwem certyfikatów i kryptografii klucza publicznego. Jednakże samo szyfrowanie wiadomości może okazać się niewystarczające.

Wyobraźmy sobie następujący scenariusz: atakującemu udaje się podstawić ofierze swój klucz publiczny (np. w formie spreparowanego certyfikatu), do którego posiada sparowany klucz prywatny. Niczego niepodejrzewający nadawca używa fałszywego klucza publicznego, sądząc, że należy on do prawowitego odbiorcy. Atakujący, po odczytaniu oryginalnej wiadomości, może później przekazać wiadomość do prawdziwego odbiorcy, szyfrując ją właściwym kluczem publicznym. W takim przypadku uczestnicy komunikacji nie będą mieli pojęcia, że ktoś *wciął* się w komunikację. Taki atak określa się mianem *Man-in-the-Middle*.

Aby zapobiec opisanej sytuacji, **certyfikaty cyfrowe służą również do potwierdzenia tożsamości i autentyczności ich właściciela**. Infrastruktura klucza publicznego umożliwia także powiązanie certyfikatów cyfrowych, wydawanych przez organ CA (*Certificate Authority*), z konkretną osobą bądź urządzeniem. Dzięki temu jesteśmy w stanie, do pewnego stopnia, ufać, że posiadacze takich certyfikatów są osobami, za które się podają. Jest to możliwe dzięki wykorzystaniu [podpisów cyfrowych](https://vilya.pl/comptia-security-sy0-701-digital-signatures-pl/) (ang. *digital signatures*). **Każdy certyfikat powinien być podpisany cyfrowo przez organ wydający dany certyfikat (CA).**

Jak dobrze pamiętamy, podpis cyfrowy to nic innego jak [hash](https://vilya.pl/sy0-701-hashing-pl/) (skrót) wyliczony na podstawie treści wiadomości i zaszyfrowany za pomocą klucza prywatnego osoby podpisującej się. Autentyczność podpisu jest natomiast weryfikowana z użyciem klucza publicznego tej osoby, czyli najpierw odszyfrowujemy hash dołączony do komunikatu, a następnie sprawdzamy, czy uzyskamy identyczny skrót z otrzymanej wiadomości (jeśli będzie inny, to znaczy, że ktoś *majstrował* przy treści).

Zaufanie do autentyczności certyfikatów cyfrowych jest podstawą PKI, dlatego tak istotna jest rola zaufanych podmiotów certyfikacyjnych CA, potwierdzających tożsamość właścicieli, którym te certyfikaty wydano. Krótko mówiąc: gdy odwiedzamy stronę z certyfikatem, przeglądarka weryfikuje dołączony podpis cyfrowy zaufanego CA, żeby potwierdzić, że tożsamość właściciela tego certyfikatu została odpowiednio zweryfikowana.
## Public key
Wyjaśniliśmy już sobie, że klucze kryptograficzne to określone wartości, wykorzystywane przez odpowiednie algorytmy do szyfrowania i odszyfrowania danych. **W szyfrowaniu asymetrycznym używamy dwóch różnych kluczy - jeden służy do szyfrowania (klucz publiczny), a drugi do odszyfrowania (klucz prywatny) wiadomości**.

Jest to możliwe dzięki **matematycznej relacji między dwoma kluczami**, które są generowane w ramach tego samego procesu, w skład którego wchodzą m.in. losowość i operacje na dużych liczbach pierwszych. Warto również dodać, że pomimo istnienia matematycznej relacji pomiędzy kluczami, **nie da się uzyskać klucza prywatnego na podstawie klucza publicznego**.

Uproszczony proces komunikacji z użyciem szyfrowania asymetrycznego:
1. Generujemy parę kluczy (publiczny i prywatny). Prywatny zachowujemy dla siebie, a publicznym dzielimy się ze znajomymi.
2. Znajomy, który chce wysłać nam wiadomość, używa naszego klucza publicznego do jej zaszyfrowania. Warto przy okazji zaznaczyć, że jeśli informacja zostanie zaszyfrowana kluczem publicznym odbiorcy, to bez jego klucza prywatnego odszyfrowanie tej informacji będzie niemożliwe i nawet nadawca nie będzie w stanie tego zrobić.
3. Otrzymujemy zaszyfrowaną wiadomość (*ciphertext*).
4. Używamy naszego klucza prywatnego, który jest powiązany z kluczem publicznym, celem odszyfrowania wiadomości i odczytania oryginalnego komunikatu.
5. Jeśli chcemy odpowiedzieć znajomemu również w poufny sposób, będziemy oczywiście potrzebować należącego do niego klucza publicznego.

Systemy kryptograficzne oparte na szyfrowaniu asymetrycznym, czyli parze kluczy, skalują się dużo lepiej niż systemy symetryczne. Przyjmijmy, że mamy `n` użytkowników systemu, którzy chcą się ze sobą komunikować w sposób poufny. W przypadku szyfrowania symetrycznego, każda para użytkowników powinna posiadać osobny klucz współdzielony do nawiązania poufnej komunikacji (chyba że wszyscy używają tego samego klucza, ale wtedy komunikacja wewnątrz systemu przestaje być tajna), co powoduje, że liczbę potrzebnych kluczy można opisać wzorem: `n(n-1)/2`. Przy większej liczbie użytkowników te wartości szybko rosną (np. przy 100 użytkownikach potrzebujemy 4950 kluczy). Natomiast w szyfrowaniu asymetrycznym wystarczy, że każdy z użytkowników posiada jedną parę kluczy (prywatny i publiczny), wtedy całkowita liczba wymaganych kluczy to `2n`.

Oprócz szyfrowania wiadomości, klucze asymetryczne umożliwiają stosowanie podpisów cyfrowych, co zostało dokładniej opisane w opracowaniu [CompTIA Security+ SY0-701: Digital signatures (PL)](https://vilya.pl/comptia-security-sy0-701-digital-signatures-pl/).
## Private key
**Klucz prywatny** (ang. *private key*), jak sama nazwa wskazuje, **jest kluczem poufnym, który powinien być znany tylko jego właścicielowi**. Termin *klucz prywatny* może mieć dwojakie znaczenie: **w przypadku kryptografii symetrycznej oznacza klucz współdzielony (ang. *shared*), wykorzystywany zarówno do zaszyfrowania, jak i odszyfrowania wiadomości, a w przypadku kryptografii asymetrycznej wskazuje na tajny klucz będący w parze z kluczem publicznym**.

Ochrona kluczy prywatnych jest sprawą najwyższej wagi w bezpiecznej komunikacji, ponieważ jeśli trafią one w niepowołane ręce, nawet najbardziej wyrafinowany algorytm na nic się nie zda. O tym, jak istotna jest ochrona kluczy prywatnych, może zaświadczyć fakt, że wiele osób zajmujących się kryptografią trzyma się [zasady Kerckhoffsa](https://pl.wikipedia.org/wiki/Zasada_Kerckhoffsa), która mówi, że **algorytm kryptograficzny powinien być niemożliwy do złamania lub obejścia bez znajomości klucza, nawet jeśli zasada jego działania jest powszechnie znana**.

Trochę innym podejściem jest tzw. *bezpieczeństwo poprzez niejawność* (ang. *security through obscurity*), które głosi, że dobrym zabezpieczeniem jest utajenie zasad działania samego algorytmu. To stanowisko jest jednak dziś szeroko krytykowane ze względu na duże ryzyko przeoczenia pomyłki projektowej lub błędu wynikającego z implementacji. Powszechnie znane algorytmy są poddawane nieustannej kryptoanalizie, zarówno przez badaczy, jak i przez cyberprzestępców - wiele par oczu przekłada się na mniej przeoczonych błędów.

Ponieważ klucze są podstawą bezpieczeństwa systemów szyfrujących, należy poświęcić odpowiednią dozę uwagi na zarządzanie nimi. Kryptografia symetryczna stawia trochę inne wyzwania niż kryptografia asymetryczna, jeśli chodzi o klucze prywatne. Przyjrzyjmy się więc głównym aspektom zarządzania tajnymi kluczami:

- **Bezpieczne przechowywanie** - wymaganie w tej materii jest stosunkowo jasne: klucz prywatny jest zawsze poufny i nie może wpaść w niepowołane ręce. Aby zwiększyć poziom bezpieczeństwa, można zastosować się do następujących zasad:  
	- W przypadku kryptografii asymetrycznej, podczas generowania pary kluczy, można dodatkowo zabezpieczyć dostęp do klucza prywatnego hasłem. Dzięki temu klucz nie będzie mógł zostać użyty do odszyfrowania danych bez znajomości hasła.  
	- Dobrym pomysłem jest przechowywanie klucza prywatnego poza systemem, w którym znajdują się zaszyfrowane dane. W razie udanego ataku na system i uzyskania nieupoważnionego dostępu do danych, atakujący nie będzie miał łatwego dostępu do klucza, a zaszyfrowane dane pozostaną bezużyteczne.  
	- W szczególnych sytuacjach można rozważyć podzielenie klucza na dwie części i przekazanie ich dwóm osobom z organizacji (każda z nich zna tylko swoją część), które muszą później współpracować, aby odtworzyć pełny klucz.  
	- Może się również zdarzyć, że klucz prywatny po prostu zaginie i dostęp do zaszyfrowanych danych zostanie utracony. Aby zapobiec takim sytuacjom, można przechowywać kopię klucza prywatnego w bezpiecznym miejscu (więcej informacji w sekcji *key escrow* poniżej).  
- **Wymiana klucza** (ang. *key exchange*) - ten problem dotyczy przede wszystkim kryptografii symetrycznej i staje się jeszcze bardziej uciążliwy, kiedy rośnie liczba użytkowników lub urządzeń, którym należy taki klucz wydać. Często stosowanym podejściem jest, wspomniane już wcześniej, nawiązanie bezpiecznego kanału komunikacji z użyciem kryptografii asymetrycznej w celu przekazania tajnego klucza współdzielonego.  
- **Unieważnienie klucza** - kiedy klucz prywatny zostanie ujawniony (przypadkowo bądź wskutek ataku), nie może być dalej używany. W przypadku szyfrowania symetrycznego, gdzie klucz jest współdzielony, problematyczne staje się nawet zwykłe odejście pracownika z organizacji. Zgodnie z zasadami bezpieczeństwa należy wygenerować nowy klucz i wszystkie dane zaszyfrować ponownie z jego użyciem. Przy stosowaniu szyfrowania asymetrycznego wystarczy wycofać z użycia klucz publiczny osoby, która odeszła z firmy (lub jej klucz prywatny wyciekł).
## Key escrow
Silna kryptografia uniemożliwia odczytanie zaszyfrowanych informacji osobom nieupoważnionym, ale pamiętajmy, że my również ich nie odzyskamy, jeśli zgubimy klucz prywatny. Podobnie kłopotliwą sytuacją jest nagłe *zniknięcie* z organizacji osoby posiadającej jedyny tajny klucz niezbędny do odszyfrowania określonych danych.

Aby zapobiegać skutkom takich zdarzeń, stosuje się **zewnętrzne (oferowane przez firmy trzecie) lub wewnętrzne systemy przechowywania kopii tajnych kluczy**, które można odzyskać wyłącznie w sytuacjach alarmowych. Takie systemy noszą nazwę *key escrow* (angielskie słowo *escrow* w dosłownym tłumaczeniu oznacza *depozyt*, *przechowanie* lub *powiernictwo*).

Dostęp do kopii zapasowych kluczy powinien być ściśle chroniony. Dlatego firmy korzystające z takich rozwiązań powinny mieć jasno zdefiniowaną politykę odzyskiwania kluczy (ang. *key recovery*), która dokładnie opisuje, w jakich konkretnych sytuacjach klucz może zostać odzyskany z depozytu i przez kogo.

**Podsumowując:** *key escrow* to system przechowywania i odzyskiwania kluczy prywatnych, do których dostęp - w razie potrzeby - posiadają wyłącznie uprawnione osoby.
# Hashing
Skrót (ang. *hash, hash-code, fingerprint*) jest to **nieuporządkowany ciąg znaków o stałej długości, wygenerowany za pomocą specjalnej funkcji matematycznej na podstawie wejściowego ciągu znaków o dowolnej długości**. Proces obliczania skrótu (ang. *hashing*): dane wejściowe dowolnej długości -> funkcja hashująca -> tekstowy łańcuch znaków (ang. *string*) o stałej długości, zależnej od rodzaju zastosowanej funkcji.

Hash - cechy charakterystyczne:
- **Stała długość** - niezależnie od rozmiaru danych wejściowych, wynik funkcji hashującej jest stałej długości. Na przykład, dla algorytmu SHA256, wynik zawsze będzie miał rozmiar 256 bitów (32 bajty).
- **Nieodwracalność** - w przeciwieństwie do szyfrowania (ang. *encryption*), odzyskanie danych wejściowych na podstawie skrótu jest (a przynajmniej powinno być) obliczeniowo trudne.
- **Odporność na kolizje** - kolizją (ang. *collision*) nazywamy sytuację, w której dwie różne wartości na wejściu spowodują wygenerowanie identycznego hasha i jest to zjawisko niepożądane. Pamiętajmy, że funkcje hashujące zwracają ciąg znaków o stałej długości, więc zakres wartości tych funkcji będzie zawsze mniejszy od zbioru danych wejściowych. Oznacza to, że hipotetycznie kiedyś do kolizji dojść musi. Istnieją jednak algorytmy (np. funkcje z rodziny SHA2 i SHA3), które mają tak duży zakres danych wyjściowych, że jeszcze nie odnaleziono dla nich przykładów kolizji. Natomiast dla algorytmu MD5 odnotowano kolizje już w 1996 roku, dlatego nie powinno się go wykorzystywać do krytycznych funkcjonalności, takich jak np. przechowywanie haseł.

Przykład: skrót [SHA256](https://emn178.github.io/online-tools/sha256.html) dla tekstu `admin123`, to `240be518fabd2724ddb6f04eeb1da5967448d7e831c08c8fa822809f74c720a9`. Nawet niewielka zmiana w danych wejściowych spowoduje wygenerowanie zupełnie innego skrótu. Na przykład, jeśli do tekstu wejściowego z powyższego przykładu dodamy jedynie wykrzyknik (`admin123!`), to hash będzie wyglądał już całkowicie inaczej: `5c06eb3d5a05a19f49476d694ca81a36344660e9d5b98e3d6a6630f31c2422e7`.

Przykładowe zastosowania hashingu:
- **Gwarancja niezmienności danych** - możemy wykorzystać unikatowy charakter skrótu do wygenerowania sygnatury dla określonych danych. Jeśli nie mamy pewności, czy ściągnięty plik nie został zmodyfikowany gdzieś _po drodze_, możemy dla pewności porównać sygnaturę ściągniętego pliku (jego hash), uzyskaną za pomocą wskazanego algorytmu, z tą udostępnioną dla oryginalnego pliku.
- **Przechowywanie haseł** - trzymanie haseł użytkowników w postaci czystego tekstu jest bardzo złym pomysłem ze względu na potencjalne wycieki danych. Dlatego w bazach danych, zamiast jawnych haseł, przechowuje się wyniki kryptograficznych funkcji skrótu, charakteryzujące się nieodwracalnością i silną odpornością na kolizje. Kiedy użytkownik podaje hasło w ramach procesu uwierzytelniania, zostaje wyliczony skrót z użyciem identycznej funkcji i jest on porównywany z tym zapisanym w bazie.
- **Podpisy elektroniczne** - dzięki nim wiemy, że dane zostały przesłane przez zaufanego nadawcę. Hash pełni tutaj funkcję pomocniczą, jako sygnatura oryginalnych danych, która później jest jeszcze szyfrowana za pomocą algorytmu szyfrowania asymetrycznego. Dzięki temu sam podpis elektroniczny nie generuje ogromnego narzutu dodatkowy bajtów do wysłania.
- **Łatwe porównywanie zawartości plików** – jeśli chcemy szybko porównać zawartość plików tekstowych, to zamiast całych plików, w bazie możemy przechowywać tylko skrót wyliczony na podstawie tejże zawartości. Wiedząc, że nawet niewielka zmiana powoduje wygenerowanie zupełnie innego skrótu, możemy wykorzystać tę właściwość do szybkiego porównywania i zidentyfikowania ewentualnych duplikatów.
- **Technologia _blockchain_** - w dużym uproszczeniu: _blockchain_ to nic innego jak rozproszona baza danych z zapisanym łańcuchem transakcji, do którego stale dodawane są nowe transakcje. Transakcją może być np. informacja o tym, że ktoś zakupił bądź sprzedał określoną ilość Bitcoinów. Zastosowanie skrótów pozwala na zweryfikowanie czy nowa transakcja jest prawdziwa i dozwolona, zanim zostanie dodana do łańcucha.

W przypadku weryfikacji ściągniętych plików możemy spotkać się z pojęciem sumy kontrolnej (ang. *checksum*). Należy zaznaczyć, że choć hash może być wykorzystany jako suma kontrolna, to jednak jest to zupełnie inny mechanizm. Celem stosowania sum kontrolnych jest sprawdzenie, czy nie wystąpiły przypadkowe błędy w czasie transmisji danych (np. podczas wysyłania przez sieć lub zapisu na nośniku danych). W związku z tym, używają one prostszych i szybszych algorytmów, ale przez to nie są odporne na kolizje i można w łatwy sposób je sfałszować.
# Salting
Uzyskanie oryginalnej wartości na podstawie hasha jest praktycznie niemożliwe, jednakże realne jest jej odgadnięcie metodą siłową (ang. *brute force*): obliczamy skróty dla kolejnych wartości, aż otrzymamy hash identyczny z tym, który próbujemy *złamać*.

W przypadku bardzo prostych (uznawanych za słabe) haseł może nastąpić to bardzo szybko. Techniką przyspieszającą ataki siłowe są [tęczowe tablice](https://vilya.pl/sy0-601-metody-lamania-hasel/#rainbow-table) (ang. *rainbow table*), czyli przygotowane wcześniej bazy wyrażeń wraz z ich wstępnie wyliczonymi skrótami. Taka baza przypomina trochę skompresowaną strukturę *[lookup table](https://en.wikipedia.org/wiki/Lookup_table)*, gdzie możemy szybko odnaleźć interesującą nas parę hash-hasło.

Aby utrudnić ataki siłowe prowadzące do złamania hasha, stosuje się tzw. **solenie (ang. *salting*). Proces ten polega na dodaniu losowego łańcucha znaków, zwanego solą (ang. *salt*), do oryginalnej wartości, jeszcze przed obliczeniem skrótu**. Na przykład: do hasła `admin123` dodajemy sól o losowej wartości `c56Tfrcb5`, więc ostatecznie funkcja hashująca otrzyma na wejściu wyrażenie `admin123c56Tfrcb5`.

Do każdego użytkownika przeważnie jest przypisana inna sól, dzięki czemu, nawet jeśli pojawią się powtórzone hasła, ich skróty będą znacząco się różnić. Podczas procesu uwierzytelniania, kiedy użytkownik podaje swoje hasło, przed obliczeniem skrótu celem porównania, dodawana jest odpowiednia sól.

Istnieje ryzyko, że wartość soli, która jest przechowywana w bazie danych, może również zostać wykradziona wraz z skrótami haseł - w takim przypadku atak siłowy ciągle jest możliwy, ale utrudniony.
# Digital signatures
**Podpis cyfrowy** (ang. *digital signature*) to mechanizm bazujący na **szyfrowaniu asymetrycznym**, wykorzystujący matematyczną relację pomiędzy kluczem publicznym (ang. *public key*) i prywatnym (ang. *private key*), a jego celem jest zagwarantowanie **niezmienności** (*integrity*) oraz **niezaprzeczalności** (*non-repudiation*) podczas komunikacji. Innymi słowy: **zapewnia, że wiadomość pochodzi od domniemanego nadawcy i nie została w żaden sposób naruszona (intencjonalnie bądź przypadkowo) podczas transmisji danych**.

**Podpis cyfrowy nie gwarantuje poufności** (ang. *confidentiality*). Jeśli nadawca chce wysłać tajny komunikat, używa publicznego klucza odbiorcy do zaszyfrowania całej wiadomości. Odbiorca, po jej otrzymaniu, może odszyfrować treść za pomocą swojego klucza prywatnego.

W przypadku podpisów cyfrowych działa to trochę inaczej: **nadawca używa swojego klucza prywatnego do zaszyfrowania skrótu (*digest*; *hash*) oryginalnej wiadomości**. Jest to nic innego jak podpis cyfrowy, dołączany do przesyłanego komunikatu, który może być wysłany w postaci jawnej. **Odbiorca najpierw uzyskuje skrót poprzez odszyfrowanie otrzymanego podpisu za pomocą klucza publicznego nadawcy. Następnie sam generuje skrót otrzymanej wiadomości, używając tego samego algorytmu hashującego i sprawdza, czy dwa skróty są identyczne**.

Uproszczony przykład:
1. Nadawca chce wysłać ważny komunikat o treści: *Do kogo należy czarna Alfa Romeo, która blokuje wjazd dla mojej fury?*
2. Najpierw liczony jest hash (można spotkać się również z terminem: *digest*) powyższej wiadomości, który może wyglądać następująco: `202143dc887c251745bd7e8a5677b8603b52eb40b729192a86ed9dd3425c19bf` ([SHA256](https://emn178.github.io/online-tools/sha256.html)).
3. Hash jest następnie szyfrowany z użyciem klucza prywatnego nadawcy. 
4. Do odbiorcy wysyłana jest oryginalna wiadomość wraz z dołączonym podpisem (zaszyfrowanym skrótem).
5. Odbiorca odszyfrowuje dołączony podpis za pomocą klucza publicznego nadawcy, który (jak sama nazwa wskazuje) jest ogólnodostępny. W wyniku powinien otrzymać hash: `202143dc887c251745bd7e8a5677b8603b52eb40b729192a86ed9dd3425c19bf`.
6. Aby stwierdzić autentyczność otrzymanego komunikatu, odbiorca powinien ponownie wyliczyć skrót z otrzymanej wiadomości, używając tego samego algorytmu (w przykładzie jest to SHA256). Jeśli wartości obu skrótów są identyczne, mamy pewność, że wiadomość nie została w żaden sposób naruszona i pochodzi od właściciela klucza publicznego.

Podpisy cyfrowe znajdują zastosowanie nie tylko w komunikacji pomiędzy stronami, ale również do podpisywania kodu. Dzięki temu mamy pewność, że aktualizacja oprogramowania (*patch*), którą chcemy zainstalować, pochodzi z zaufanego źródła.

Do potwierdzenia **spójności** oraz **uwierzytelnienia** (ang. *authentication*) wiadomości można jeszcze wykorzystać mechanizm **MAC** (*Message Authentication Code*), który w odróżnieniu od *pełnoprawnych* podpisów używa **współdzielonego klucza prywatnego** (ang. *shared private key*) do utworzenia znacznika MAC. Mechanizm ten jest trochę wydajniejszy ze względu na wykorzystanie szyfrowania symetrycznego, jednakże **nie gwarantuje niezaprzeczalności**. ponieważ każdy, kto jest w posiadaniu klucz prywatnego może wygenerować prawidłowy kod MAC.

**HMAC** (*Hash-Based Message Authentication Code*) jest wyspecjalizowaną techniką nadawania sygnatury MAC. Działa na podobnej zasadzie, jednakże może różnić się sposobem obliczania znacznika. Jak sama nazwa wskazuje, mechanizm HMAC używa w tym celu tylko kryptograficznej funkcji skrótu, gdzie w przypadku MAC można wykorzystać jeszcze m.in. symetryczne szyfrowanie blokowe (w skrócie: MAC jest bardziej ogólnym terminem).
# Key stretching
Hasła nigdy nie powinny być przechowywane w jawnej postaci (ang. *plain text*), więc przeważnie zapisuje się je w formie skrótów (ang. *hashing*) obliczonych za pomocą kryptograficznych funkcji skrótu.

Obliczenie takiego skrótu jest operacją, która zajmuje trochę czasu. Z perspektywy użytkownika są dzieje się to przeważnie w mgnieniu oka, jednakże dla procesora czynność, która trwa nawet kilka milisekund jest już uznawana za czasochłonną. Może się wydawać, że pożądane jest błyskawiczne obliczanie skrótów, jednakże należy mieć na uwadze, że **szybkie funkcje hashujące to także skuteczniejsze ataki siłowe** (można sprawdzić więcej skrótów w krótszym czasie).

Aby utrudnić ataki typu *brute-force*, oprócz dodawania soli (ang. *salting*) do haseł, stosuje się również technikę o nazwie ***key stretching*. Jest to celowe wydłużenie czasu obliczeń wykonywanych przez funkcję skrótu. Implementacja tej techniki polega zazwyczaj na kilkukrotnym wywołaniu funkcji hashującej odpornej na kolizje** - czyli z hasła jest liczony skrót, potem z tego skrótu liczony jest kolejny skrót i tak dalej. Okazuje się bowiem, że **w przypadku funkcji silnie odpornych na kolizje, wielokrotne wyliczanie skrótu nie zwiększa prawdopodobieństwa znalezienia kolizji**.

Użytkownikowi logującemu się do systemu nie robi tak naprawdę różnicy, czy weryfikacja jego danych potrwa 5 czy 200 milisekund, ale dla atakującego, który jest zmuszony sprawdzić miliony kombinacji, jest to już bardzo znaczące utrudnienie, bo całkowity czas potrzebny na złamanie hasła mocno się wydłuża.

W związku z powyższym, aktualnie zaleca się stosowanie **funkcji z rodziny PBKDF** (*Password-Based Key Derivation Function*). Są to specjalne funkcje, dedykowane dla systemów kryptograficznych, które łączą w sobie zalety funkcji skrótu wraz z dodatkowymi technikami zabezpieczeń, takimi jak np. *key stretching* czy wspomniane wcześniej *solenie* haseł.
# Materiały źródłowe
- [Professor Messer’s CompTIA SY0-701 Security+ Training Course](https://www.professormesser.com/security-plus/sy0-701/sy0-701-video/sy0-701-comptia-security-plus-course/)
- [CompTIA Security+ Study Guide SY0-701, Mike Chapple, David Seidl](https://www.amazon.com/CompTIA-Security-Study-Practice-Questions/dp/1394211414)
- [IBM: What is public key infrastructure?](https://www.ibm.com/think/topics/public-key-infrastructure)
- [IBM Tech Talk: What is Public Key Infrastructure (PKI)?](https://www.youtube.com/watch?v=0ctat6RBrFo)
- [Hash vs. Checksum: Understanding the Difference and Their Role in Cybersecurity](https://medium.com/@mustafa_kamal/hash-vs-checksum-understanding-the-difference-and-their-role-in-cybersecurity-95c6c4a2aff3)
- [CISA: Understanding Digital Signatures](https://www.cisa.gov/news-events/news/understanding-digital-signatures)
- [StackOverflow: Digital signature for a file using openssl](https://stackoverflow.com/questions/10782826/digital-signature-for-a-file-using-openssl)
- [Okta: How HMAC Works](https://www.okta.com/identity-101/hmac/)
- [SY0-601: Metody łamania haseł](https://vilya.pl/sy0-601-metody-lamania-hasel/)