# Explain various types of vulnerabilities
Wyjaśnij różne typy podatności.
# Application
TBD
## Memory injection
TBD
## Buffer overflow
Swego czasu, bardzo popularne było wykorzystywanie podatności związanych z niewłaściwym zarządzaniem pamięci poprzez tzw. **przepełnienie bufora** (ang. *buffer overflow*). Nie wdając się w szczegóły techniczne, **atakujący był w stanie wprowadzić więcej danych do aplikacji (*input*) niż przewidział to jej twórca. Jeśli program otrzymał na wejściu większą liczbę bajtów niż zarezerwowany obszar pamięci (bufor), to mówiąc w przenośni, nadmiarowe bajty *wylewały* się poza zarezerwowany bufor, nadpisując sąsiadujące komórki pamięci**.

W większości przypadków, powodowało to błąd naruszenia pamięci ([*segmentation fault*](https://en.wikipedia.org/wiki/Segmentation_fault)) i zakończenie działania programu. Jednakże okazało się, że **w niektórych przypadkach można przepełnić bufor i nadpisać pamięć w taki sposób, żeby program, zamiast się *wykrzaczyć*, wykonał przekazany na wejściu, specjalnie spreparowany kod**. Przeważnie był to tzw. kod wywołania powłoki ([*shellcode*](https://en.wikipedia.org/wiki/Shellcode)), dający atakującemu dostęp do skompromitowanego systemu (zakładając, że zaatakowany program działał z uprawnieniami administratora systemu).

Żeby lepiej zrozumieć to zagadnienie, zróbmy sobie błyskawiczne i mocno uproszczone wprowadzenie do zarządzania pamięcią w systemach operacyjnych. Uruchomiony program (proces) potrzebuje określonej ilości pamięci do prawidłowego działania. Im bardziej złożona jest aplikacja, tym więcej pamięci operacyjnej potrzebuje (innymi słowy, im więcej RAM-u, tym gry chodzą płynniej ;)).

Aby ułatwić aplikacjom dostęp do fizycznej pamięci operacyjnej RAM (_Random Access Memory_) oraz do pamięci trwałej (nośniki danych), został opracowany mechanizm **pamięci wirtualnej** (ang. *virtual memory*). Dzięki niemu procesy, czyli uruchomione aplikacje, mają do swojej dyspozycji ciągły i spójny obszar pamięci, który jest zmapowany na często pofragmentowaną pamięć fizyczną (przydzielone obszary są *porozrzucane* w różnych miejscach):

![[2-3-buffer-overflow-virtual-memory.png]]

Przestrzeń adresowa procesu, widoczna na powyższej grafice, to po prostu fragment pamięci przydzielony uruchomionej aplikacji. Ta przestrzeń również ma swoją określoną strukturę i składa się m.in. z [segmentu danych](https://en.wikipedia.org/wiki/Data_segment) (ang. *data segment*), [segmentu kodu](https://en.wikipedia.org/wiki/Code_segment) (ang. *code segment*), a także miejsca zawierającego tzw. **adres powrotu** (ang. *return address*), wskazującego na następną instrukcję, którą program ma wykonać. W tej przestrzeni są oczywiście przechowywane dane wykorzystywane przez program, włącznie z informacjami przekazanymi przez użytkownika.

Spróbujmy sobie teraz zobrazować na czym polega przepełnienie bufora. Wyobraźmy sobie, że mamy program wymagający od użytkownika podania imienia i nazwiska, które są później zapisywane w pamięci aplikacji. Przyjmijmy również, że zmienna `first_name` jest w stanie pomieścić tylko 8 znaków (dla uproszczenia przyjmijmy również, że jeden znak to jeden bajt) i program nie sprawdza w żaden sposób długości wprowadzanego imienia. Co się stanie, gdy użytkownik poda imię *Aleksandra*?

![[2-3-buffer-overflow-example.png]]

Widzimy, że zmienna (bufor) nie była w stanie zmieścić podanej informacji, co spowodowało nadpisanie bufora zarezerwowanego dla zmiennej `last_name` – nastąpiło przepełnienie (ang. *overflow*).

Pamiętajmy, że jest to bardzo mocno uproszczona wizualizacja, której celem jest przedstawienie zagadnienia w sposób intuicyjny. W rzeczywistości atakujący musiałby przygotować ładunek (ang. *payload*), który zmodyfikowałby pamięć w taki sposób, żeby nadpisać wspomniany wcześniej adres powrotu wartością wskazującą na wstrzyknięty kod. Jest to szalenie trudne do wykonania, a jeszcze trudniejsze do powtórzenia, szczególnie przy dzisiejszych zabezpieczeniach.

Podsumowując, **atak polega na wprowadzeniu większej ilości danych do zarezerwowanego obszaru pamięci programu, niż ten obszar jest w stanie pomieścić. Prowadzi to do nadpisania sąsiadujących komórek pamięci, co w większości przypadków spowoduje awarię działającej aplikacji bądź systemu. Jednak w określonych okolicznościach umożliwia atakującemu wykonanie złośliwego kodu, *wstrzykniętego* do pamięci skompromitowanego programu**.
## Race conditions
TBD
### Time-of-check (TOC)
TBD
### Time-of-use (TOU)
TBD
## Malicious update
TBD
